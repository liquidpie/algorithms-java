package com.vivek.graph.examples;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Minimize Malware Spread
 *
 * You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.
 * Some nodes initial are initially infected by malware. Whenever two nodes are directly connected,
 * and at least one of those two nodes is infected by malware, both nodes will be infected by malware.
 * This spread of malware will continue until no more nodes can be infected in this manner.
 *
 * Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.
 * We will remove exactly one node from initial.
 *
 * Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial),
 * return such a node with the smallest index.
 *
 * Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.
 *
 * Example 1:
 *
 * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
 * Output: 0
 *
 * Example 2:
 *
 * Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
 * Output: 0
 *
 * Example 3:
 *
 * Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
 * Output: 1
 *
 * Solution:
 * First, let's segregate the nodes of each component (or subgraph) of the graph. We can do this using a depth first search.
 *
 * Afterwards, notice that if two nodes in initial have the same subgraph id (ie., belong to the same component),
 * then removing them from initial won't decrease M(initial).
 * This is because the malware will spread to reach every node in this component no matter what.
 *
 * So, among nodes with a unique subgraph id (meaning only one source node) in initial, we will remove the node with the largest component size.
 * (If there's a tie, we return the smallest index. Also, if there aren't any nodes with a unique subgraph id,
 * we'll just return the smallest index node.)
 *
 * Algorithm
 *
 * This algorithm has a few parts:
 *
 *     - Segregating each component: For each node, if it isn't yet marked, use a depth-first search to traverse its subgraph,
 *                                   mark that node with a new subgraph id.
 *
 *     - Size of each subgraph: Count the number of nodes part of each subgraph.
 *
 *     - Find unique subgraphs: Look at the subgraph ids of nodes in initial to see which nodes are part of unique of subgraphs.
 *                              Not repeating the same subgraphs
 *
 *     - Choose answer: For each node with a unique subgraph, find the size of that subgraph.
 *                      The largest size is selected, with ties broken by lowest node number.
 *                      If there is no node with a unique subgraph id, the answer is min(initial).
 *
 * Complexity Analysis
 *
 *     Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
 *
 *     Space Complexity: O(N).
 *
 * Reference:
 * https://leetcode.com/problems/minimize-malware-spread/description/
 */
public class MinimizeMalwareSpread {

    public int minMalwareSpread(int[][] graph, int[] initial) {
        // find sub graphs
        SubGraph[] nodeSubgraph = new SubGraph[graph.length];
        int subgraphId = 0;
        for (int i = 0; i < graph.length; i++) {
            if (nodeSubgraph[i] == null) {
                SubGraph currentSubgraph = new SubGraph(++subgraphId);
                dfs(graph, i, nodeSubgraph, currentSubgraph);
            }
        }

        int[] uniqSubgraphs = new int[subgraphId + 1];
        for (int node : initial) {
            uniqSubgraphs[nodeSubgraph[node].id]++;
        }
        // find the node
        int result = Integer.MAX_VALUE;
        for (int node : initial) {
            if (uniqSubgraphs[nodeSubgraph[node].id] == 1) {
                if (result == Integer.MAX_VALUE) {
                    result = node;
                } else if (nodeSubgraph[node].size > nodeSubgraph[result].size) {
                    result = node;
                } else if (nodeSubgraph[node].size == nodeSubgraph[result].size && node < result) {
                    result = node;
                }
            }
        }

        if (result == Integer.MAX_VALUE) {
            for (int node :  initial)
                result = Math.min(result, node);
        }

        return result;
    }

    void dfs(int[][] graph, int currentNode, SubGraph[] nodeSubgraph, SubGraph currentSubgraph) {
        nodeSubgraph[currentNode] = currentSubgraph;
        currentSubgraph.size++;
        for (int j = 0; j < graph[currentNode].length; j++) {
            if (graph[currentNode][j] == 1 && nodeSubgraph[j] == null) {
                dfs(graph, j, nodeSubgraph, currentSubgraph);
            }
        }
    }

    static class SubGraph {
        int id;
        int size;

        SubGraph(int id) {
            this.id = id;
        }
    }

    /**
     * Hackerarnk specific method signature
     *
     * @param n     the number of nodes
     * @param edgeStart array to store the start of the edge index by index. edgeStart[i] -> edgeEnd[i] forms an edge
     * @param edgeEnd array to store the end of the index
     * @param malware array to specify whether a particular node is infected or not. 1 for infected, 0 for not injected
     *
     * https://leetcode.com/discuss/interview-question/5806979
     */
    int minMalwareSpread(int n, int[] edgeStart, int[] edgeEnd, int[] malware) {
        int[][] graph = new int[n][n];
        for (int i = 0; i < edgeStart.length; i++) {
            graph[edgeStart[i] - 1][edgeEnd[i] - 1] = 1;
            graph[edgeEnd[i] - 1][edgeStart[i] - 1] = 1;
        }
        List<Integer> initialList = new ArrayList<Integer>();
        for (int i = 0; i < n; i++) {
            if (malware[i] == 1) {
                initialList.add(i);
            }
        }
        int[] initial = initialList.stream().mapToInt(Integer::intValue).toArray();

        return minMalwareSpread(graph, initial) + 1;
    }

    public static void main(String[] args) {
        MinimizeMalwareSpread driver = new MinimizeMalwareSpread();
        {
            int[][] graph = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
            int[] initial = {0, 1, 2};
            int node = driver.minMalwareSpread(graph, initial);
            System.out.println(node);
        }

        {
            int n = 9;
            int[] edgeStart = {1, 2, 4, 6, 7};
            int[] edgeEnd = {2, 3, 5, 7, 8};
            int[] malware = {0, 0, 1, 0, 1, 0, 0, 0, 0};
            int node = driver.minMalwareSpread(n, edgeStart, edgeEnd, malware);
            System.out.println(node);
        }
    }

}
